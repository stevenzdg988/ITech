<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Anaconda+VSCode配置Python开发学习环境</title>
    <url>/ITech/2020/12/15/Anaconda-VSCode%E9%85%8D%E7%BD%AEPython%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当前，流行语很多，其中“大数据”、“人工智能”、“信息化”、“教育信息化”备受关注，而其核心的工具大多都指向了 <strong>Python</strong>者们程序设计语言，不论是生产环境的开发，还是关乎国计民生的 <strong>教育</strong>，都在向它倾斜。近几年来，教育主管部门更是发布了重磅的政策性的指导意见，可见从事教育的一线工作者掌握这门语言是多么的迫在眉睫，它不仅能提高自身的工作效率，更能在其职业的高度上认识信息社会发展的契机和理论认识，进而引领学习者开阔视野，能够适应当今社会发展，能够对社会发展激发出更加活跃的创造力。本文从一个最最基础的角度，聊一聊 <strong>Python</strong> 学习、开发环境的配置，但更多的偏重于搭建 <strong>Python</strong> 学习环境。</p>
<span id="more"></span>

<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><strong>Python</strong>，关于其的信息铺天盖地，培训机构、学习网站充斥了互联网各个角落。<strong>Python</strong> 中文名是蟒蛇。<strong>Python</strong>的创始人为荷兰人吉多·范·罗苏姆（Guido van Rossum）。1989年圣诞节期间，在阿姆斯特丹，为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，作为ABC 语言的一种继承。之所以选中 <strong>Python</strong>（大蟒蛇的意思）作为该编程语言的名字，是取自英国20世纪70年代首播的电视喜剧《蒙提.派森的飞行马戏团》（Monty Python’s Flying Circus）。</p>
<p><strong>Python</strong> 是一种解释型脚本语言，可以应用于以下领域 Web 和 网络开发、 科学计算和统计、 人工智能、 桌面界面开发、 软件开发、 网络爬虫、 黑客最喜欢的语言。</p>
<p><strong>Python</strong> 的主要运用领域有:</p>
<p>云计算：云计算最热的语言，典型的应用OpenStack</p>
<p>WEB开发：许多优秀的WEB框架，许多大型网站是Python开发、YouTube、Dropbox、Douban……典型的Web框架包括Django</p>
<p>科学计算和人工智能：典型的图书馆 NumPy、SciPy、Matplotlib、Enided 图书馆、熊猫</p>
<p>系统操作和维护：操作和维护人员的基本语言</p>
<p>金融：定量交易、金融分析，在金融工程领域，Python不仅使用最多，而且使用最多，其重要性逐年增加。</p>
<p>图形 GUI：PyQT，WXPython，TkInter</p>
<p><strong>Python</strong> 在一些公司的运用有:</p>
<p>谷歌：谷歌应用程序引擎，代码。Google.com、 Google 爬虫、Google 广告和其他项目正在广泛使用 <strong>Python</strong>。</p>
<p>CIA：美国中情局网站是用 <strong>Python</strong> 开发的。</p>
<p>NASA：美国航天局广泛使用 <strong>Python</strong> 进行数据分析和计算。</p>
<p>YouTube：世界上最大的视频网站 YouTube 是用 <strong>Python</strong> 开发的。</p>
<p>Dropbox：美国最大的在线云存储网站，全部用 <strong>Python</strong> 实现，每天处理 10 亿的文件上传和下载。</p>
<p>Instagram：美国最大的照片共享社交网站，每天有 3000 多万张照片被共享，所有这些都是用 <strong>Python</strong> 开发的。</p>
<p>Facebook：大量的基本库是通过 <strong>Python</strong> 实现的</p>
<p>Red Hat/Centos：世界上最流行的 Linux 发行版中的 Yum 包管理工具是用 <strong>Python</strong> 开发的</p>
<p>Douban：几乎所有公司的业务都是通过 <strong>Python</strong> 开发的。</p>
<p>知乎：中国最大的 Q＆A 社区，通过 <strong>Python</strong> 开发（国外 Quora）</p>
<p>除此之外，还有搜狐、金山、腾讯、盛大、网易、百度、阿里、淘宝、土豆、新浪、果壳等公司正在使用 <strong>Python</strong> 来完成各种任务。</p>
<p>信息化时代的应用真是太多太多了，不仅 <strong>Python</strong> 能做到，其他的程序语言也可以做到，只是为什么选择它？我们从 <strong>Python</strong>之禅中可以获得一些答案吧：<br>    Beautiful is better than ugly.<br>    优美胜于丑陋（Python以编写优美的代码为目标）<br>    Explicit is better than implicit.<br>    明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）<br>    Simple is better than complex.<br>    简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）<br>    Complex is better than complicated.<br>    复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）<br>    Flat is better than nested.<br>    扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）<br>    Sparse is better than dense.<br>    间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）<br>    Readability counts.<br>    可读性很重要（优美的代码是可读的）<br>    Special cases aren’t special enough to break the rules.<br>    Although practicality beats purity.<br>    即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）<br>    Errors should never pass silently.<br>    Unless explicitly silenced.<br>    不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码）<br>    In the face of ambiguity, refuse the temptation to guess.<br>    当存在多种可能，不要尝试去猜测<br>    There should be one– and preferably only one –obvious way to do it.<br>    而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）<br>    Although that way may not be obvious at first unless you’re Dutch.<br>    虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）<br>    Now is better than never.<br>    Although never is often better than <em>right</em> now.<br>    做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）<br>    If the implementation is hard to explain, it’s a bad idea.<br>    If the implementation is easy to explain, it may be a good idea.<br>    如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）<br>    Namespaces are one honking great idea – let’s do more of those!<br>    命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</p>
<p>学习<strong>Python</strong> <a href="https://www.python.org/">官网</a> 是一个能找到不错文档的地方，同样也能找到搭建 <strong>Python</strong> 环境的核心<a href="https://www.python.org/downloads/">安装文件</a>,但是仅仅依靠其远不能达到要求，这个时候就需要加载一些第三方的应用（模块），其中之一就是 <strong>Anaconda</strong> 。</p>
<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><p><strong>Anaconda</strong>，水蚺(南美洲蟒蛇)，和蟒蛇是同类吧，就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了 <strong>conda、Python</strong> 在内的超过180个科学包及其依赖项。昂，原来 <strong>Anaconda</strong> 是一个 <strong>Python</strong> 的大管家啊！</p>
<h2 id="Windows系统下的安装操作"><a href="#Windows系统下的安装操作" class="headerlink" title="Windows系统下的安装操作"></a>Windows系统下的安装操作</h2><p>由于某种原因， <strong>Anaconda</strong> 的官网我们无法访问，文档也需要从其他第三方的网站去查询，幸好我们国内有网站提供了其镜像的下载，经常用的速度比较快的<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">清华镜像站下载</a>，此镜像站提供了适用多平台的安装包，感觉还是下载最新版本吧，如果你用的是Windows平台，那么就在这里下载 <em>Anaconda3-5.3.1-Windows-x86.exe</em> 或者 <em>Anaconda3-5.3.1-Windows-x86_64.exe</em> 吧，区别是前一个适合32位操作系统平台，后一个适合64位操作系统平台，至今感觉后一种比较普遍了。若是在Linux平台安装，在后面会详细介绍。</p>
<p>那就双击下载下来的安装文件进行安装吧，安装非常简单，一直下一步（next）默认安装就可以了，只是这个软件包含的应用众多，体量比较大，所用时间比较长，等等就好啦。给一张安装界面吧：<br>    <img src="https://img-blog.csdnimg.cn/20201216101019919.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="Anaconda安装"><br>安装完成就可以在系统开始菜单里找到 <strong>Anaconda</strong> 的应用程序了，如图：<br>    <img src="https://img-blog.csdnimg.cn/20201216101631215.png#pic_center" alt="Anaconda程序菜单"></p>
<p>嗯，我们找到 <strong>Anaconda Promot</strong> 利用右键单击选择 <code>以管理员身份运行</code>,<br>    <img src="https://img-blog.csdnimg.cn/20201216102530638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="conda promot启动"><br>你就会看到 <strong>CMD</strong> 窗口<br>    <img src="https://img-blog.csdnimg.cn/20201216102623819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="conda操作界面"><br>接下来键入 <code>conda --help</code>，显示 <strong>Anaconda</strong> 管理 <strong>Python</strong> 应用模块的命令提示信息。<br>    <img src="https://img-blog.csdnimg.cn/20201216103244327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="conda帮助"><br>常用的同步更新软件包（update）、安装软件包（install）。不管是更新还是安装，都需要到软件官网去获取软件信息，由于某种原因这些操作都是非常困难的，因此需要对软件默认的配置修改成国内的快速镜像地址，这样才能高效。<br>在当前用户的根目录下创建 <code>.condarc</code> 文件，因为在 Windows系统下无法创建以”.”开头的文件，因此需要利用命令行进项操作，让其生成 <code>.condarc</code> 文件，然后利用文本编辑软件打开，编辑如下内容后保存退出。<br>    <img src="https://img-blog.csdnimg.cn/20201216110459956.png#pic_center" alt=".condarc文件生成"><br>    <img src="https://img-blog.csdnimg.cn/20201216111056674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt=".condarc文件位置"><br>    <img src="https://img-blog.csdnimg.cn/20201216110509888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt=".condarc文件配置"><br>再利用 <code>conda</code> 命令获取软件的过程中可能会用到 <code>pip</code> 进行一些下载，因此也需要将 <code>pip</code> 配置成国内的快速镜像地址，具体做法是，在当前用户根目录下创建 <code>pip</code> 文件夹，并且在此文件夹内创建 <code>pip.ini</code> 文件，利用文本编辑器编辑如下图内容到此文件后保存退出。<br>    <img src="https://img-blog.csdnimg.cn/20201216111319848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="pip配置文件位置"><br>    <img src="https://img-blog.csdnimg.cn/20201216110653435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="pip配置文件创建"></p>
<h2 id="Linux系统下的安装"><a href="#Linux系统下的安装" class="headerlink" title="Linux系统下的安装"></a>Linux系统下的安装</h2><p>本文以 Manjaro 操作系统为例配置Anaconda。<br>首先配置更新源， <code>code /etc/pacman.conf</code> 在文档末尾加上两行，配置 <strong>archlinuxcn</strong> 更新源，如下图：<br>    <img src="https://img-blog.csdnimg.cn/20201216114847736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="pacman.conf配置archlinuxcn"><br>然后执行 <code>sudo pacman -Syy</code> 和 <code>sudo pacman -Syu</code> 进行系统镜像数据库拉取和更新，然后安装 <strong>archlinuxcn</strong> KEY, <code>sudo pacman -S archlinuxcn-keyring</code> ，如下图：<br>    <img src="https://img-blog.csdnimg.cn/20201216120110837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="archlinux-keyring安装"><br>接下来就开始安装 <strong>Anaconda</strong> 了， <code>sudo pacman -S anaconda</code> ,输入“y”，进行安装，一路回车，遇到选“yes”还是“no”的时输入“yes”，然后回车即可，在这里就不截图了。一壶茶过后就可以了。<br>    <img src="https://img-blog.csdnimg.cn/20201216120626439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="anaconda安装"><br>然后配置更新镜像源，跟 Windows 一样在 当前用户的根目录下 <code>/home/eric/.condarc</code>, <strong>pip</strong> 镜像配置文件需要利用命令： <code>mkdir -p /home/eric/.pip</code> <code>touch /home/eric/.pip/pip.conf</code> 创建。然后通过命令 <code>code /home/eric/.condarc </code> 和 <code>code /home/eric/.pip/pip.conf</code> 分别打开这两个文件将在本文 Windows部分提及的内容编辑进文件保存退出就OK了（不提供截图了）。<br>Linux下启动 <strong>Anaconda</strong> 如下图：<br>    <img src="https://img-blog.csdnimg.cn/20201216122739617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="anaconda启动"><br>接下来的操作和在Windows下操作无异，祝好运吧。</p>
<h1 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h1><p>Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。该编辑器支持多种语言和文件格式的编写，截止2019年9月，已经支持了如下37种语言或文件：F#、HandleBars、Markdown、Python、Java、PHP、Haxe、Ruby、Sass、Rust、PowerShell、Groovy、R、Makefile、HTML、JSON、TypeScript、Batch、Visual Basic、Swift、Less、SQL、XML、Lua、Go、C++、Ini、Razor、Clojure、C#、Objective-C、CSS、JavaScript、Perl、Coffee Script、Dockerfile。</p>
<p>到被誉为神级编辑器的<a href="https://code.visualstudio.com/">VSCode下载地址</a>下载对应平台的源码包或二进制安装文件安装即可，关于其中的操作可以到其官网查阅文档，这里不做赘述了。</p>
<p>好啦，下面就来更新一下你的大水蚺吧！！<br>若有新的应用，那就依照前面所述 <code>conda install xxx</code> 吧，接下来你就在 <strong>Python</strong> 的海洋里遨游吧。</p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
        <tag>Python</tag>
        <tag>VSCode</tag>
        <tag>Manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言实现Server-Client</title>
    <url>/ITech/2020/12/20/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0Server-Client/</url>
    <content><![CDATA[<p>利用C语言实现客户端浏览器访问服务器和服务器与客户端交互两个场景。</p>
<span id="more"></span>
<h2 id="模拟利用浏览器访问服务器"><a href="#模拟利用浏览器访问服务器" class="headerlink" title="模拟利用浏览器访问服务器"></a>模拟利用浏览器访问服务器</h2><p>代码如下(Server-Browser)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">*by GeekBear</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#define PORT 8080</span><br><span class="line">&#x2F;&#x2F;监听的端口号</span><br><span class="line">#define MAX_CONNECT 20</span><br><span class="line">最大连接数</span><br><span class="line">#define BUFFER_SIZE 1024*32</span><br><span class="line">&#x2F;&#x2F;32k缓冲区满足绝大多数网页请求</span><br><span class="line">#define NAME_BUFFER_SIZE 1024</span><br><span class="line">&#x2F;&#x2F;路径缓冲 </span><br><span class="line">#define HTTP_END &quot;\r\n\r\n&quot;</span><br><span class="line">&#x2F;&#x2F;http协议头以两个回车换行结尾</span><br><span class="line">#define BASE_DIR &quot;.&#x2F;100_www&#x2F;&quot;</span><br><span class="line">&#x2F;&#x2F;服务器根目录设为当前程序运行路径</span><br><span class="line">#define DEFAULT_PAGE &quot;&#x2F;index.html&quot;</span><br><span class="line">&#x2F;&#x2F;默认页面</span><br><span class="line">#define HTTP_OK &quot;HTTP&#x2F;1.1 200 OK\r\n\r\n&quot;</span><br><span class="line">&#x2F;&#x2F;http正常回应</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void *doAccept(void * parm);           </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;做协议解析 </span><br><span class="line">static void *doProc(void *data);</span><br><span class="line"></span><br><span class="line">int writeFile(int fd,char *filePath);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    printf(&quot;start!\n&quot;);</span><br><span class="line">    printf(&quot;按回车键退出!\n&quot;);</span><br><span class="line">    bzero(&amp;thread,sizeof(thread));</span><br><span class="line">    pthread_create(&amp;thread,NULL,doAccept,NULL);</span><br><span class="line">    getchar();</span><br><span class="line">    printf(&quot;end!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void *doAccept(void * parm)</span><br><span class="line">&#123;</span><br><span class="line">    int socketfd,connectfd;</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    struct sockaddr_in serverAddr;</span><br><span class="line">    pthread_t pthread;</span><br><span class="line">    signal(SIGCHLD,SIG_IGN);</span><br><span class="line">    signal(SIGPIPE,SIG_IGN);</span><br><span class="line">    socketfd &#x3D; socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    if(socketfd &#x3D;&#x3D; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;创建套接字失败!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;创建套接字成功!\n&quot;);</span><br><span class="line">        bzero(&amp;serverAddr,sizeof(serverAddr));</span><br><span class="line">        serverAddr.sin_family&#x3D;AF_INET;</span><br><span class="line">        serverAddr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);</span><br><span class="line">        serverAddr.sin_port &#x3D; htons(PORT);</span><br><span class="line">        if( -1&#x3D;&#x3D;bind(socketfd,(struct sockaddr*)&amp;serverAddr,sizeof(struct sockaddr)) )</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;FIXME 绑定端口失败时发生段错误！ </span><br><span class="line">            printf(&quot;绑定端口失败！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;绑定端口成功！\n&quot;);</span><br><span class="line">            if(-1&#x3D;&#x3D;listen(socketfd,MAX_CONNECT))</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;创建监听失败！\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;创建监听成功！\n&quot;);</span><br><span class="line">                printf(&quot;在浏览器中输入http:&#x2F;&#x2F;127.0.0.1:%d来访问本服务器\n&quot;,PORT);</span><br><span class="line">                while(1)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;sleep(1);</span><br><span class="line">                    socklen_t socketLen&#x3D;0;</span><br><span class="line">                    connectfd &#x3D; accept(socketfd,(struct sockaddr*)&amp;serverAddr,&amp;socketLen);</span><br><span class="line">                    if(connectfd&lt;&#x3D;0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;接受连接失败！\n&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;接受连接成功！\n&quot;);</span><br><span class="line">                        bzero(&amp;thread,sizeof(thread));</span><br><span class="line">                        pthread_create(&amp;thread,NULL,doProc,(void*)(intptr_t)connectfd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;做协议解析 </span><br><span class="line">static void *doProc(void *data)</span><br><span class="line">&#123;</span><br><span class="line">    int connectfd &#x3D; (int)(intptr_t)data;</span><br><span class="line">    char *buffer &#x3D; (char *)malloc(BUFFER_SIZE+1);</span><br><span class="line">    if(buffer&#x3D;&#x3D;NULL)</span><br><span class="line">        printf(&quot;malloc return NULL!&quot;);</span><br><span class="line">    int readLen&#x3D;read(connectfd,buffer,BUFFER_SIZE);</span><br><span class="line">    if(readLen&lt;&#x3D;0)</span><br><span class="line">        goto END;</span><br><span class="line">    buffer[readLen]&#x3D;0;</span><br><span class="line">    &#x2F;&#x2F;printf(&quot;%s&quot;,buffer);</span><br><span class="line">    int endLen &#x3D; strlen(HTTP_END);</span><br><span class="line">    if( (readLen&gt;&#x3D;endLen) &amp;&amp; (strcmp(buffer+readLen-endLen,HTTP_END)&#x3D;&#x3D;0) )</span><br><span class="line">    &#123;&#x2F;&#x2F;是http协议</span><br><span class="line">        printf(&quot;%s&quot;,buffer);</span><br><span class="line">        char *startPos&#x3D;strstr(buffer,&quot;GET &quot;);</span><br><span class="line">        </span><br><span class="line">        if(startPos!&#x3D;NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            startPos+&#x3D;4;</span><br><span class="line">            char *endPos&#x3D;strstr(startPos,&quot; &quot;);</span><br><span class="line">            if(endPos!&#x3D;NULL&amp;&amp;(endPos-startPos)&lt;NAME_BUFFER_SIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                char *nameBuffer&#x3D;malloc(NAME_BUFFER_SIZE+1);</span><br><span class="line">                if(nameBuffer&#x3D;&#x3D;NULL)</span><br><span class="line">                    printf(&quot;malloc return NULL!&quot;);</span><br><span class="line">                nameBuffer[0]&#x3D;0;</span><br><span class="line">                strcat(nameBuffer,BASE_DIR);</span><br><span class="line">                strncat(nameBuffer,startPos,endPos-startPos);</span><br><span class="line">                if(nameBuffer[strlen(nameBuffer)-1]&#x3D;&#x3D;&#39;&#x2F;&#39;)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;is_dir,use default page.\n&quot;);</span><br><span class="line">                    strcat(nameBuffer,DEFAULT_PAGE);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;*</span><br><span class="line">                &#x2F;&#x2F;判断路径是否为文件夹，不安全 </span><br><span class="line">                struct stat st;</span><br><span class="line">                stat(nameBuffer,&amp;st);</span><br><span class="line">                if (S_ISDIR(st.st_mode))</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;is_dir,use default page.\n&quot;);</span><br><span class="line">                    strcat(nameBuffer,DEFAULT_PAGE);</span><br><span class="line">                &#125;*&#x2F;</span><br><span class="line">                printf(&quot;GET:%s\n&quot;,nameBuffer);</span><br><span class="line">                writeFile(connectfd,nameBuffer);</span><br><span class="line">                free(nameBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">END:</span><br><span class="line">    &#x2F;&#x2F;printf(&quot;end doProc\n&quot;);</span><br><span class="line">    free(buffer);</span><br><span class="line">    close(connectfd);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int writeFile(int fd,char *filePath)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;printf(&quot;write file:%s\n&quot;,filePath);</span><br><span class="line">    int fileHandler&#x3D;open(filePath,0,O_RDONLY);</span><br><span class="line">    if(fileHandler&lt;&#x3D;0)</span><br><span class="line">        return -1;</span><br><span class="line">    char *buffer&#x3D;(char *)malloc(BUFFER_SIZE+1);</span><br><span class="line">    if(buffer&#x3D;&#x3D;NULL)</span><br><span class="line">        printf(&quot;malloc return NULL!&quot;);</span><br><span class="line">    write(fd,HTTP_OK,strlen(HTTP_OK));</span><br><span class="line">    int readLen&#x3D;0;</span><br><span class="line">    while( 0&lt;(readLen&#x3D;read(fileHandler,buffer,BUFFER_SIZE)) )</span><br><span class="line">    &#123;</span><br><span class="line">        write(fd,buffer,readLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(buffer);</span><br><span class="line">    close(fileHandler);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码存储为server-browser.c，利用VSCode或命令行（<strong>gcc server-broser.c -o hostt.exe</strong>)进行编译生成可执行文件，Windows下为hostt.exe，打开系统下的命令提示符 <em>cmd</em> 将目录切换到程序所在目录，键入 <em>hostt.exe</em> 回车执行在窗口显示如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213579.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server-browser1"></p>
<p>然后打开浏览器按照提示信息将<em><a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></em>复制到浏览器的地址栏里访问，这时命令提示符窗口就会有反馈信息输出，代表模拟成功，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213655.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server-browser2"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213670.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server-browser3"></p>
<h2 id="模拟客户端与服务端进行交互"><a href="#模拟客户端与服务端进行交互" class="headerlink" title="模拟客户端与服务端进行交互"></a>模拟客户端与服务端进行交互</h2><p>首先创建服务端代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">*by GeekBear</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PORT 8090</span><br><span class="line">&#x2F;&#x2F;监听的端口号</span><br><span class="line">#define MAX_CONNECT 20</span><br><span class="line">&#x2F;&#x2F;最大连接数</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char readBuffer[101];</span><br><span class="line">    char writeBuffer[201];</span><br><span class="line">    int socketfd,connectfd;</span><br><span class="line">    struct sockaddr_in serverAddr;</span><br><span class="line">    signal(SIGPIPE,SIG_IGN);</span><br><span class="line">    &#x2F;&#x2F;屏蔽管道破解信号，一般服务器都会屏蔽这个型号 </span><br><span class="line">    socketfd &#x3D; socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    &#x2F;&#x2F;创建套接字 </span><br><span class="line">    if(socketfd &#x3D;&#x3D; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;创建套接字失败!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;创建套接字成功!\n&quot;);</span><br><span class="line">        bzero(&amp;serverAddr,sizeof(serverAddr));</span><br><span class="line">        &#x2F;&#x2F;相当于memset</span><br><span class="line">        serverAddr.sin_family&#x3D;AF_INET;</span><br><span class="line">        &#x2F;&#x2F;ipv4</span><br><span class="line">        serverAddr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);</span><br><span class="line">        &#x2F;&#x2F;设定监听的地址为任何地址都监听</span><br><span class="line">        serverAddr.sin_port &#x3D; htons(PORT);</span><br><span class="line">        &#x2F;&#x2F;设置端口号</span><br><span class="line">        &#x2F;&#x2F;套接字与端口和地址绑定</span><br><span class="line">        if( -1&#x3D;&#x3D;bind(socketfd,(struct sockaddr*)&amp;serverAddr,sizeof(struct sockaddr)) )</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;绑定端口失败！\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;绑定端口成功！\n&quot;);</span><br><span class="line">            &#x2F;&#x2F;创建监听</span><br><span class="line">            if(-1&#x3D;&#x3D;listen(socketfd,MAX_CONNECT))</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;创建监听失败！\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;创建监听成功！\n&quot;);</span><br><span class="line">                printf(&quot;地址:127.0.0.1:%d\n&quot;,PORT);</span><br><span class="line">                while(1)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;sleep(1);</span><br><span class="line">                    socklen_t socketLen&#x3D;0;</span><br><span class="line">                    &#x2F;&#x2F;等待客户端的连接到达 </span><br><span class="line">                    connectfd &#x3D; accept(socketfd,(struct sockaddr*)&amp;serverAddr,&amp;socketLen);</span><br><span class="line">                    if(connectfd&lt;&#x3D;0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;接受连接失败！\n&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf(&quot;接受连接成功！\n&quot;);</span><br><span class="line">                        &#x2F;&#x2F;接收数据 </span><br><span class="line">                        int readLength&#x3D;read(connectfd,readBuffer,100);</span><br><span class="line">                        if(readLength&gt;0)</span><br><span class="line">                        &#123;</span><br><span class="line">                            readBuffer[readLength]&#x3D;0;</span><br><span class="line">                            printf(&quot;收到消息:%s,长度:%d\n&quot;,readBuffer,readLength);</span><br><span class="line">                            sprintf(writeBuffer,&quot;received your msg:&#39;%s&#39;\n&quot;,readBuffer);</span><br><span class="line">                            &#x2F;&#x2F;发送数据</span><br><span class="line">                            write(connectfd,writeBuffer,strlen(writeBuffer));</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F;关闭与客户端的连接</span><br><span class="line">                        close(connectfd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;FIXME 关闭套接字不知道是不是这个方法，反正感觉关闭失败了  </span><br><span class="line">        close(socketfd);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;程序结束\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建客户端程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">#include &lt;arpa&#x2F;inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">*by GeekBear</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char readBuffer[101];</span><br><span class="line">    char writeBuffer[201];</span><br><span class="line">    int connectRet,socketfd;</span><br><span class="line">    struct sockaddr_in clientAddr;</span><br><span class="line">    &#x2F;&#x2F;signal(SIGPIPE,SIG_IGN);</span><br><span class="line">    &#x2F;&#x2F;屏蔽管道破解信号，一般服务器都会屏蔽这个型号 </span><br><span class="line">    socketfd &#x3D; socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    &#x2F;&#x2F;创建套接字 ,AF_NET:ipv4，SOCK_STREAM:TCP协议 </span><br><span class="line">    if(socketfd &#x3D;&#x3D; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;创建套接字失败!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;return 0;</span><br><span class="line">        printf(&quot;创建套接字成功!\n&quot;);</span><br><span class="line">        bzero(&amp;clientAddr,sizeof(clientAddr));&#x2F;&#x2F;相当于memset</span><br><span class="line">        clientAddr.sin_family&#x3D;AF_INET;&#x2F;&#x2F;ipv4</span><br><span class="line">        &#x2F;&#x2F;ip地址:0x7f000001:127.0.0.1</span><br><span class="line">        &#x2F;&#x2F;0x7f:127</span><br><span class="line">        clientAddr.sin_addr.s_addr&#x3D;htonl(0x7f000001);</span><br><span class="line">        clientAddr.sin_port &#x3D; htons(8090);</span><br><span class="line">        &#x2F;&#x2F;设置端口号</span><br><span class="line">        connectRet&#x3D;connect(socketfd,(struct sockaddr*)&amp;clientAddr,sizeof(struct sockaddr));</span><br><span class="line">        if(-1&#x3D;&#x3D;connectRet)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;连接到服务器失败!\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;连接到服务器成功!\n&quot;);</span><br><span class="line">            printf(&quot;请输入要发送的消息并回车:&quot;);</span><br><span class="line">            scanf(&quot;%s&quot;,writeBuffer);</span><br><span class="line">            write(socketfd,writeBuffer,strlen(writeBuffer));</span><br><span class="line">            int readLength&#x3D;read(socketfd,readBuffer,100);</span><br><span class="line">            if(readLength&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                readBuffer[readLength]&#x3D;0;</span><br><span class="line">                printf(&quot;收到的消息:%s\n&quot;,readBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(socketfd);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;程序结束\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来将两个程序进行编译，分别生成 <em>server.exe</em> 和 <em>client.exe</em> ，分别打开2个命令提示符窗口，在其中一个执行 <em>server.exe</em> 在另一个执行 <em>client.exe</em> ，在执行 <em>client.exe</em>的窗口中输入信息，回车后会在执行服务端程序的窗口显示在 <em>client.exe</em> 窗口中输入的内容，进而实现了模拟服务器端与客户机端的信息交互过程。</p>
<p>如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213577.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213573.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="client"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213576.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="interactive1"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213522.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="interactive2"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213520.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="interactive3"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220152213473.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="interactive4"></p>
<p>是不是很有趣？我觉着很有趣，下一步将用Python来实现一下这个过程，敬请期待。。。</p>
<p><img src="https://img-blog.csdnimg.cn/20201218081104595.jpg#pic_center" alt="logo"></p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Server-Client</tag>
        <tag>Server-Browser</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 博客测试中。。。</title>
    <url>/ITech/2021/04/11/GitHub-%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95%E4%B8%AD%E3%80%82%E3%80%82%E3%80%82/</url>
    <content><![CDATA[<p>吐槽？吐槽！<br>作为一个全栈代码爱好者，很是痛心，技术应该是无国界的，因为某些原因，使得无法达到这个目标。。。加油吧！！！</p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title>HangInThere</title>
    <url>/ITech/2020/12/19/HangInThere/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20201219000658706.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="1"></p>
<p><img src="https://img-blog.csdnimg.cn/20201219000658664.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="2"></p>
<p><img src="https://img-blog.csdnimg.cn/20201219000658660.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="3"></p>
<p><img src="https://img-blog.csdnimg.cn/20201218081104595.jpg#pic_center" alt="logo"></p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>杂货铺</category>
      </categories>
      <tags>
        <tag>HangInThere</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 备用页面环境测试</title>
    <url>/ITech/2021/03/23/GitHub-%E5%A4%87%E7%94%A8%E9%A1%B5%E9%9D%A2%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h3 id="GitHub-主页出问题后重新恢复，故做相关测试。"><a href="#GitHub-主页出问题后重新恢复，故做相关测试。" class="headerlink" title="GitHub 主页出问题后重新恢复，故做相关测试。"></a>GitHub 主页出问题后重新恢复，故做相关测试。</h3><link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客在多台终端同步管理</title>
    <url>/ITech/2020/12/15/Hexo%E5%8D%9A%E5%AE%A2%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="Hexo-Github博客在多台终端同步管理"><a href="#Hexo-Github博客在多台终端同步管理" class="headerlink" title="Hexo+Github博客在多台终端同步管理"></a>Hexo+Github博客在多台终端同步管理</h2><p>最近这两天研究Hexo制作个人博客，发现自己放了好长时间的博客系统在一次环境系统升级过后崩溃了，然后决定从零开始。在配置过程中又遇到了这样的问题，在不同的电脑终端同步博客遇到了困难，不能实现要求，然后查找了很多博文和官网的文档，最终找到了解决的办法，在此记录下来以便能帮助有需要的后来人。此方法利用Git管理Hexo产生的文件，实现在不同的电脑上同步（Github）所需的文件，也可以正常的在不同的Hexo环境里进行相应操作，只要在做完之后同步到Github的仓库里即可。下面具体来说说：</p>
<span id="more"></span>

<h2 id="搭建node-js环境"><a href="#搭建node-js环境" class="headerlink" title="搭建node.js环境"></a>搭建node.js环境</h2><h3 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h3><p>官网下载并安装<a href="https://nodejs.org/en/">Nodejs和npm</a>。</p>
<h3 id="Linux环境（本文以Manjaro为例）"><a href="#Linux环境（本文以Manjaro为例）" class="headerlink" title="Linux环境（本文以Manjaro为例）"></a>Linux环境（本文以Manjaro为例）</h3><pre><code>$sudo pacman -S nodejs npm</code></pre>
<h3 id="配置npm国内镜像源"><a href="#配置npm国内镜像源" class="headerlink" title="配置npm国内镜像源"></a>配置npm国内镜像源</h3><pre><code>$npm config set registry https://registry.npm.taobao.org</code></pre>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><h3 id="Windows环境-1"><a href="#Windows环境-1" class="headerlink" title="Windows环境"></a>Windows环境</h3><p>官网下载并安装<a href="https://git-scm.com/download/win">Git</a>。</p>
<h3 id="Linux环境（本文以Manjaro为例）-1"><a href="#Linux环境（本文以Manjaro为例）-1" class="headerlink" title="Linux环境（本文以Manjaro为例）"></a>Linux环境（本文以Manjaro为例）</h3><pre><code>sudo pacman -S git</code></pre>
<h2 id="安装Hexo（Hexo环境搭建）"><a href="#安装Hexo（Hexo环境搭建）" class="headerlink" title="安装Hexo（Hexo环境搭建）"></a>安装Hexo（Hexo环境搭建）</h2><p>这里不赘述直接给出安装方法（命令）所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<pre><code>$npm install -g hexo-cli</code></pre>
<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<pre><code>$hexo init &lt;Blog-folder&gt;
$cd &lt;Blog-folder&gt;
$npm install
$npm install hexo-deployer-git --save</code></pre>
<p>新建完成后，指定文件夹<Blog-folder>的目录如下：</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes</code></pre>
<p>之后就可以利用 <strong>hexo</strong> 命令进行一些操作，可以参看<a href="https://hexo.io/zh-cn/docs/">Hexo官网文档</a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="Github-分支管理Hexo环境目录"><a href="#Github-分支管理Hexo环境目录" class="headerlink" title="Github 分支管理Hexo环境目录"></a>Github 分支管理Hexo环境目录</h3><p>方案主要是通过维护两条git分支来实现，第一个分支是 Gihub 上默认的 <strong>master</strong> 分支，用于存放发布的博文的静态页面；另外再新建一个分支，比如命名为 <strong>Hexo</strong> ，通过此分支存放主题、原始的博客文件等等，这些文件才是不同电脑需要同步的文件；当每次修改主题或者新增博文后，先将修改的主题文件（在themes文件夹下）或者新增博客（在source文件夹下），同步到远程的 <strong>Hexo</strong> 分支，然后在通过 <em>hexo g -d</em>命令发布博文，也就是将新增的博文的静态页面同步到 <strong>master</strong> 分支。这样通过不同的分支管理不同的文件，实现了多台电脑同步更新博文的功能。</p>
<h3 id="Hexo-目录结构"><a href="#Hexo-目录结构" class="headerlink" title="Hexo 目录结构"></a>Hexo 目录结构</h3><p>当执行 <em>hexo g -d</em> 后目录结构发生了变化，如下：</p>
<pre><code>.
├── .gitignore
├── .deploy_git
|   ├── ...
|   ├── ...
|   └── ...
├── node_modules
├── public
├── package-lock.json
├── db.json
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes</code></pre>
<p>其中 <em>.deploy_git</em>、<em>public</em> 两个文件夹下存放的是博客文章的静态页面，通过对比 Github 上博客仓库的<strong>master</strong>分支可以看到<strong>master</strong>分支下面的文件结构和 <em>.deploy_git</em> 文件夹下的文件是一致的，这个应该可以判断通过 <em>hexo g -d</em> 发布到 Github 的内容就是 <em>.deploy_git</em> 文件夹下面的文件。其余的文件夹和文件即是<strong>Hexo</strong>的主题文件、原始的博客文件等，刚在上文提到的<strong>Hexo</strong>分支，存的即时这些文件。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="创建分支（在-Github上操作）"><a href="#创建分支（在-Github上操作）" class="headerlink" title="创建分支（在 Github上操作）"></a>创建分支（在 Github上操作）</h3><p>首先在Github上面创建一个分支命名为Hexo，Hexo 是从master 拉取，所以分支的文件和 master 一样。</p>
<h3 id="初始化分支（PC1上面操作）"><a href="#初始化分支（PC1上面操作）" class="headerlink" title="初始化分支（PC1上面操作）"></a>初始化分支（PC1上面操作）</h3><p>在已经部署好Hexo环境的PC1上的安装Hexo的根目录下拉取 Hexo 分支，步骤如下：</p>
<pre><code>git clone 仓库地址</code></pre>
<p>将仓库文件拉取到本地，生成的文件名为 username.github.io；进入username.github.io文件夹，除了 <em>.git</em> 文件夹以外，其他文件全部删除；</p>
<pre><code>git add .</code></pre>
<p>将修改提交至暂存区；</p>
<pre><code>git commit -m “提交说明”</code></pre>
<p>提交本次修改；</p>
<pre><code>git push origin Hexo</code></pre>
<p>将本次修改推送到远端 Hexo；将刚才未删除的 <em>.git</em> 文件夹拷贝至Hexo根目录，删除 <em>username.github.io</em> 文件夹，此时本地的Hexo目录已与 Github上面的 Hexo 文件夹关联了，而且默认的   <em>.gitignore</em> 已经配置了忽略规则，所以已经可以将根目录下的文件同步上去，还是依次调用 <em>git add .</em> 、<em>git commit -m ‘comment’*、 *git push origin Hexo</em> 三个命令将当前的文件推送至远程的 Hexo分支。</p>
<h3 id="同步分支（PC2上面操作）"><a href="#同步分支（PC2上面操作）" class="headerlink" title="同步分支（PC2上面操作）"></a>同步分支（PC2上面操作）</h3><p>此时在PC2上，创建文件夹Blog，在Blog文件夹下面还行以下操作：</p>
<pre><code>git clone 仓库地址 BlogName
git clone -b Hexo 仓库地址 hexo.repo</code></pre>
<p>在clone下来的仓库文件夹中将<em>hexo.repo</em> 文件夹下的文件拷贝到 <em>BlogName</em> 目录中，然后安装和配置hexo环境，依次调用命令： <em>npm install hexo</em>、<em>npm install</em>、<em>npm install hexo-deployer-git</em>；（不需要<em>hexo init</em>）此时通过命令 <em>hexo g</em>、<em>hexo s</em>即可在本地开启同步下来的博客静态页面，并通过 <em><a href="http://localhost:4000/">http://localhost:4000/</a></em> 访问。</p>
<h3 id="发布博文（PC1或者PC2）"><a href="#发布博文（PC1或者PC2）" class="headerlink" title="发布博文（PC1或者PC2）"></a>发布博文（PC1或者PC2）</h3><p>后续不管是PC1还是PC2，如果修改了主题或者新增了博文，按照以下步骤即可：</p>
<pre><code>git add .
git commit -m “修改说明”
git push origin hexo
hexo g -d</code></pre>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>技术研究是在反复咀嚼的过程中提高的，伴随着咀嚼的过程时常会感到一丝丝的甜美无比的感觉，走在技术研究路上渣渣们，加油！！</p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Nodejs</tag>
        <tag>Git</tag>
        <tag>Markdown语法</tag>
      </tags>
  </entry>
  <entry>
    <title>MSYS2配置总结（恢复）</title>
    <url>/ITech/2020/04/11/MSYS2%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93-2020-04-11/</url>
    <content><![CDATA[<p><a href="http://www.msys2.org/">MSYS2下载：</a><br>MSYS2是什么？MSYS2 （Minimal SYStem 2） 是一个MSYS的独立改写版本，主要用于 shell 命令行开发环境。同时它也是一个在Cygwin （POSIX 兼容性层） 和 MinGW-w64（从”MinGW-生成”）基础上产生的，追求更好的互操作性的 Windows 软件。MSYS2 是MSYS的一个升级版,准确的说是集成了pacman和Mingw-w64的Cygwin升级版, 提供了bash shell等linux环境、版本控制软件（git/hg）和MinGW-w64 工具链。与MSYS最大的区别是移植了 Arch Linux的软件包管理系统 Pacman(其实是与Cygwin的区别)。</p>
<span id="more"></span>

<p>特点:</p>
<pre><code>* 安装方便,自带 pacman 管理，可以使用 pkgtool 来 makepkg,较快的源速度（可以修改源地址）,自带软件和库较全而且比较新,使用mingw-w64工具链,可以编译32位或64位代码（需要自行安装）,中文支持好,可以直接输入和浏览中文目录。 *</code></pre>
<h3 id="MSYS2的MirrorList配置"><a href="#MSYS2的MirrorList配置" class="headerlink" title="MSYS2的MirrorList配置"></a>MSYS2的MirrorList配置</h3><p>1、修改msys2安装目录下的/etc/pacman.d文件夹里面的3个mirrorlist.*文件</p>
<p><code>[mirrorlist.mingw32]</code><br><code>#中国科学技术大学开源软件镜像</code><br><code>Server = http://mirrors.ustc.edu.cn/msys2/mingw/i686/</code><br><code>#北京理工大学开源软件镜像</code><br><code>Server = http://mirror.bit.edu.cn/msys2/REPOS/MINGW/i686</code><br><code>#清华大学开源软件镜像</code><br><code>Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686</code><br><code>日本北陆先端科学技术大学院大学 sourceforge 镜像</code><br><code>Server = http://jaist.dl.sourceforge.net/project/msys2/REPOS/MINGW/i686</code><br><code>Server = ftp://ftp.jaist.ac.jp/pub/sourceforge/m/ms/msys2/REPOS/MINGW/i686</code><br><code>Include = /etc/pacman.d/mirrorlist.mingw32</code></p>
<p><code>[mirrorlist.mingw64]</code><br><code>#中国科学技术大学开源软件镜像</code><br><code>Server = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/</code><br><code>#北京理工大学开源软件镜像</code><br><code>Server = http://mirror.bit.edu.cn/msys2/REPOS/MINGW/x86_64</code><br><code>清华大学开源软件镜像</code><br><code>Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64</code><br><code>日本北陆先端科学技术大学院大学 sourceforge 镜像</code><br><code>Server = http://jaist.dl.sourceforge.net/project/msys2/REPOS/MINGW/x86_64</code><br><code>Server = ftp://ftp.jaist.ac.jp/pub/sourceforge/m/ms/msys2/REPOS/MINGW/x86_64</code><br><code>Include = /etc/pacman.d/mirrorlist.mingw64</code></p>
<p><code>[mirrorlist.msys]</code><br><code>中国科学技术大学开源软件镜像</code><br><code>Server = http://mirrors.ustc.edu.cn/msys2/msys/$arch</code><br><code>北京理工大学开源软件镜像</code><br><code>Server = http://mirror.bit.edu.cn/msys2/REPOS/MSYS2/$arch</code><br><code>清华大学开源软件镜像</code><br><code>Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch</code><br><code>日本北陆先端科学技术大学院大学 sourceforge 镜像</code><br><code>Server = http://jaist.dl.sourceforge.net/project/msys2/REPOS/MSYS2/$arch</code><br><code>Server = ftp://ftp.jaist.ac.jp/pub/sourceforge/m/ms/msys2/REPOS/MSYS2/$arch</code><br><code>Include = /etc/pacman.d/mirrorlist.msys</code></p>
<p>2、修改/etc/pacman.conf，把下面注释行取消注释</p>
<p><code>XferCommand = /usr/bin/wget --passive-ftp -c -O %o %u</code></p>
<p>3、更新软件包</p>
<p><code>pacman -Syu</code></p>
<h3 id="常用工具安装"><a href="#常用工具安装" class="headerlink" title="常用工具安装"></a>常用工具安装</h3><p>1、查看工具套件</p>
<p><code>pacman -Sg</code></p>
<p>得到结果如下：</p>
<p><code>kf5</code><br><code>mingw-w64-i686-toolchain</code><br><code>mingw-w64-i686</code><br><code>mingw-w64-i686-gimp-plugins</code><br><code>mingw-w64-i686-qt4</code><br><code>mingw-w64-i686-qt</code><br><code>mingw-w64-i686-qt5</code><br><code>mingw-w64-i686-vulkan-devel</code><br><code>tesseract-data</code><br><code>mingw-w64-x86_64-toolchain</code><br><code>mingw-w64-x86_64</code><br><code>mingw-w64-x86_64-gimp-plugins</code><br><code>mingw-w64-x86_64-qt4</code><br><code>mingw-w64-x86_64-qt</code><br><code>mingw-w64-x86_64-qt5</code><br><code>mingw-w64-x86_64-vulkan-devel</code><br><code>libraries</code><br><code>development</code><br><code>base-devel</code><br><code>base</code><br><code>msys2-devel</code><br><code>compression</code><br><code>VCS</code><br><code>sys-utils</code><br><code>Database</code><br><code>net-utils</code><br><code>editors</code><br><code>python-modules</code><br><code>mingw-w64-cross-toolchain</code><br><code>mingw-w64-cross</code><br><code>MSYS2-devel</code><br><code>perl-modules</code></p>
<p>自行根据需要安装，一般较常用安装</p>
<p><code>pacman -S --noconfirm mingw-w64-x86_64-toolchain libraries development base-devel msys2-devel compression VCS</code></p>
<p><code>sys-utils net-utils editors python-modules</code></p>
<p><code>pacman -S --noconfirm mingw-w64-cross mingw-w64-cross-toolchain</code></p>
<p>2、常用工具</p>
<p>查看可安装软件列表</p>
<p><code>pacman -Sl</code></p>
<p>安装python</p>
<p><code>pacman -S --noconfirm mingw-w64-x86_64-python2 mingw-w64-x86_64-python2-setuptools mingw-w64-x86_64-python2-pip mingw-w64-x86_64-python2-ipython</code><br><code>pacman -S --noconfirm mingw-w64-x86_64-python3 mingw-w64-x86_64-python3-setuptools mingw-w64-x86_64-python3-pip mingw-w64-x86_64-python3-ipython</code></p>
<p>安装python科学计算库</p>
<p><code>pacman -S --noconfirm mingw-w64-x86_64-python2-numpy mingw-w64-x86_64-python2-scipy mingw-w64-x86_64-python2-matplotlib mingw-w64-x86_64-python2-pandas</code><br><code>pacman -S --noconfirm mingw-w64-x86_64-python3-numpy mingw-w64-x86_64-python3-scipy mingw-w64-x86_64-python3-matplotlib mingw-w64-x86_64-python3-pandas</code></p>
<p>安装所有python工具</p>
<p><code>pacman -Sl | grep mingw-w64-x86_64-python2 | awk &#39;&#123;print &quot;pacman -S --noconfirm &quot;$2&#125;&#39; &gt; python2-all.sh</code><br><code>sh python2-all.sh</code><br><code>pacman -Sl | grep mingw-w64-x86_64-python3 | awk &#39;&#123;print &quot;pacman -S --noconfirm &quot;$2&#125;&#39; &gt; python3-all.sh</code><br><code>sh python3-all.sh</code></p>
<p>安装nodejs(nodejs的安装貌似还有些问题）</p>
<p><code>pacman -S --noconfirm mingw-w64-x86_64-nodejs</code></p>
<p>安装帮助手册</p>
<p><code>pacman -S --noconfirm help2man man-db man-pages-posix</code></p>
<p>安装zsh和git</p>
<p><code>pacman -S --noconfirm zsh git</code></p>
<p>安装oh my zsh（此网站貌似已经废弃）</p>
<p><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></p>
<p>启动打开zsh</p>
<p><code>vim .bashrc</code></p>
<p>在文件最后一行添加，当然也可以直接在命令行中执行</p>
<p><code>exec zsh</code><br>安装vim</p>
<p><code>pacman -S --noconfirm vim</code></p>
<p>超强vim配置文件（此网站也貌似飞向了月球）</p>
<p><code>wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x</code></p>
<h3 id="Pacman-命令详解"><a href="#Pacman-命令详解" class="headerlink" title="Pacman 命令详解"></a>Pacman 命令详解</h3><p>Pacman 是一个命令行工具，这意味着当你执行下面的命令时，必须在终端或控制台中进行。</p>
<p>1、更新系统</p>
<p>在 Arch Linux 中，使用一条命令即可对整个系统进行更新：</p>
<p><code>pacman -Syu</code></p>
<p>如果你已经使用 <code>pacman -Sy</code> 将本地的包数据库与远程的仓库进行了同步，也可以只执行：</p>
<p><code>pacman -Su</code></p>
<p>2、安装包</p>
<p><code>pacman -S 包名</code> 例如，执行 <code>pacman -S firefox</code> 将安装 Firefox。你也可以同时安装多个包，只需以空格分隔包名即可。<br><code>pacman -Sy 包名</code> 与上面命令不同的是，该命令将在同步包数据库后再执行安装。<br><code>pacman -Sv 包名</code> 在显示一些操作信息后执行安装。<br><code>pacman -U 安装本地包</code>，其扩展名为 <code>pkg.tar.gz</code><br>。<br>3、删除包</p>
<p><code>pacman -R 包名</code> 该命令将只删除包，不包含该包的依赖。<br><code>pacman -Rs 包名</code> 在删除包的同时，也将删除其依赖。<br><code>pacman -Rd 包名</code> 在删除包时不检查依赖。</p>
<p>4、搜索包</p>
<p><code>pacman -Ss 关键字</code> 这将搜索含关键字的包。<br><code>pacman -Qi 包名</code> 查看有关包的信息。<br><code>pacman -Ql 包名</code> 列出该包的文件。</p>
<p>5、其他用法</p>
<p><code>pacman -Sw 包名</code> 只下载包，不安装。<br><code>pacman -Sc</code> Pacman 下载的包文件位于 /var/cache/pacman/pkg/ 目录。该命令将清理未安装的包文件。<br><code>pacman -Scc</code> 清理所有的缓存文件。</p>
<p>关于 Pacman 更加详细的用法，可以阅读Pacman 的手册页。</p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MSYS2</tag>
        <tag>Python3</tag>
        <tag>MarkdownPro2</tag>
      </tags>
  </entry>
  <entry>
    <title>PS去除图片上的文字</title>
    <url>/ITech/2020/12/18/PS%E5%8E%BB%E9%99%A4%E5%9B%BE%E7%89%87%E4%B8%8A%E7%9A%84%E6%96%87%E5%AD%97/</url>
    <content><![CDATA[<p>研究操作系统原理未必不需要Photoshop处理图片，碎片化的记录一下吧，也是当做练练文笔了。今天研究H神的时候做一个博文的logo时，需要一张图片，从网上找到了一张图片，发现有网站的水印logo，要去掉它，操作如下：</p>
<span id="more"></span>
<p>看图操作吧，打开要编辑的图片，右上角有 <em>7788.com</em> 水印，</p>
<p><img src="https://img-blog.csdnimg.cn/20201218085937576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="open"></p>
<p>点选 <strong>选择工具</strong>，将水印框选，</p>
<p><img src="https://img-blog.csdnimg.cn/20201218091628681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70#pic_center" alt="select"></p>
<p>然后选择 <strong>编辑</strong> 菜单中的 <strong>填充</strong>命令，</p>
<p><img src="https://img-blog.csdnimg.cn/20201218085937623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="fill"></p>
<p>在弹出的 <strong>填充</strong> 对话框 <strong>内容</strong> 选项中选择 <strong>内容识别</strong>，</p>
<p><img src="https://img-blog.csdnimg.cn/20201218085937598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="identify1"></p>
<p><img src="https://img-blog.csdnimg.cn/20201218085937589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="identify2"></p>
<p>然后点击 <strong>确定</strong>，就把水印去掉啦！</p>
<p><img src="https://img-blog.csdnimg.cn/20201218085937572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="complete"></p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>操作技巧</category>
      </categories>
      <tags>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 基础--运算符</title>
    <url>/ITech/2021/06/26/Python-%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>以后不定期更新文档，回顾 Python 的基础内容，也希望博友们积极参与“ 共同进步”<br>哈哈哈！！！</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a,b,c &#x3D; 20,5,4</span><br><span class="line">print(a-a*b&#x2F;a&#x2F;&#x2F;c)</span><br></pre></td></tr></table></figure>

<p>请在下面的评论区添加结果评论！！！哈哈哈！！！</p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现Server-Client</title>
    <url>/ITech/2020/12/20/Python%E5%AE%9E%E7%8E%B0Server-Client/</url>
    <content><![CDATA[<p>为了尽快的把上一篇提出的问题展示出来，翻看了Python的文档，然后实现一番，果然在代码量上远远少于C语言，更加的形象，判若一个chat！好吧，附上代码和实验截图，一睹为快吧！</p>
<span id="more"></span>

<h2 id="实现浏览器访问服务器"><a href="#实现浏览器访问服务器" class="headerlink" title="实现浏览器访问服务器"></a>实现浏览器访问服务器</h2><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from http.server import BaseHTTPRequestHandler,HTTPServer</span><br><span class="line"></span><br><span class="line">class RequestHandler(BaseHTTPRequestHandler):</span><br><span class="line">    # ...页面模板...</span><br><span class="line">    Page &#x3D; &#39;&#39;&#39;\</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Header&lt;&#x2F;td&gt;         &lt;td&gt;Value&lt;&#x2F;td&gt;          &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Date and time&lt;&#x2F;td&gt;  &lt;td&gt;&#123;date_time&#125;&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Client host&lt;&#x2F;td&gt;    &lt;td&gt;&#123;client_host&#125;&lt;&#x2F;td&gt;  &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Client port&lt;&#x2F;td&gt;    &lt;td&gt;&#123;client_port&#125;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Command&lt;&#x2F;td&gt;        &lt;td&gt;&#123;command&#125;&lt;&#x2F;td&gt;      &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;  &lt;td&gt;Path&lt;&#x2F;td&gt;           &lt;td&gt;&#123;path&#125;&lt;&#x2F;td&gt;         &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">    &lt;&#x2F;html&gt;</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">    def do_GET(self):</span><br><span class="line">        page &#x3D; self.create_page()</span><br><span class="line">        self.send_content(page)</span><br><span class="line"></span><br><span class="line">    def create_page(self):</span><br><span class="line">        values &#x3D; &#123;</span><br><span class="line">            &#39;date_time&#39;   : self.date_time_string(),</span><br><span class="line">            &#39;client_host&#39; : self.client_address[0],</span><br><span class="line">            &#39;client_port&#39; : self.client_address[1],</span><br><span class="line">            &#39;command&#39;     : self.command,</span><br><span class="line">            &#39;path&#39;        : self.path</span><br><span class="line">        &#125;</span><br><span class="line">        page &#x3D; self.Page.format(**values)</span><br><span class="line">        return page</span><br><span class="line"></span><br><span class="line">    def send_content(self, page):</span><br><span class="line">        self.send_response(200)</span><br><span class="line">        self.send_header(&quot;Content-type&quot;, &quot;text&#x2F;html&quot;)</span><br><span class="line">        self.send_header(&quot;Content-Length&quot;, str(len(page)))</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(page.encode(&#39;utf-8&#39;))</span><br><span class="line">        </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    serverAddress &#x3D; (&#39;&#39;, 8080)</span><br><span class="line">    server &#x3D; HTTPServer(serverAddress, RequestHandler)</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure>

<p>在命令提示符窗口执行 <em>python server.py</em> ，然后打开浏览器，地址栏输入 <em><a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></em> ，浏览器中显示预先设定的显示内容，同时在命令提示符窗口显示访问成功的信息。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201220212401539.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220212401474.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="browser"></p>
<h2 id="实现服务器客户端实时交互"><a href="#实现服务器客户端实时交互" class="headerlink" title="实现服务器客户端实时交互"></a>实现服务器客户端实时交互</h2><p>服务端代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">serversocket&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">host&#x3D;socket.gethostname()#获取本地主机名</span><br><span class="line">port&#x3D;9999</span><br><span class="line">#绑定端口号</span><br><span class="line">serversocket.bind((host,port))</span><br><span class="line"></span><br><span class="line">#设置最大连接数</span><br><span class="line">serversocket.listen(5)</span><br><span class="line">while True:</span><br><span class="line">    print(&#39;服务器启动，监听客户端链接&#39;)</span><br><span class="line">    clientsocket,addr&#x3D;serversocket.accept()</span><br><span class="line">    print(&#39;链接地址：%s&#39; % str(addr))</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            data&#x3D;clientsocket.recv(1024)</span><br><span class="line">        except Exception:</span><br><span class="line">            print(&#39;断开的客户端：&#39;,addr)</span><br><span class="line">            break</span><br><span class="line">        print(&#39;客户端发送内容：&#39;,data.decode(&#39;utf-8&#39;))</span><br><span class="line">        reply&#x3D;input(&#39;回复：&#39;).strip()</span><br><span class="line">        if not reply:</span><br><span class="line">            break</span><br><span class="line">        msg&#x3D;time.strftime(&#39;%Y-%m-%d %X&#39;)#获取结构化时间戳</span><br><span class="line">        msg1&#x3D;&#39;[%s]:%s&#39;% (msg,reply)</span><br><span class="line">        clientsocket.send(msg1.encode(&#39;utf-8&#39;))</span><br><span class="line">    clientsocket.close()</span><br><span class="line">serversocket.closel()</span><br></pre></td></tr></table></figure>
<p>以 <em>server-t.py</em>保存。</p>
<p>客户端代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">host&#x3D;socket.gethostname()</span><br><span class="line">port&#x3D;9999</span><br><span class="line">s.connect((host,port))</span><br><span class="line">while True:</span><br><span class="line">    data&#x3D; input(&#39;&gt;&gt;&#39;).strip()</span><br><span class="line">    if not data:</span><br><span class="line">        break</span><br><span class="line">    s.send(data.encode(&#39;utf-8&#39;))</span><br><span class="line">    msg&#x3D;s.recv(1024)</span><br><span class="line">    if not msg:</span><br><span class="line">        break</span><br><span class="line">    print(msg.decode(&#39;utf-8&#39;))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<p>以 <em>client-t.py</em> 保存。</p>
<p>分别启动两个文件所在位置的命令提示符，执行 <em>python server-t.py</em>，<em>python client-t.py</em> ，此时两个命令提示符窗口如下图，你可以在两个窗口中分别输入信息然后回车就会发送到对应的交互端，类似于一个chat了！！！挺有意思，要不你也来试试？！:)</p>
<p><img src="https://img-blog.csdnimg.cn/20201220212401429.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="server-t"></p>
<p><img src="https://img-blog.csdnimg.cn/20201220212401426.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbl96ZGc5ODg=,size_16,color_FFFFFF,t_70" alt="client-t"></p>
<p><img src="https://img-blog.csdnimg.cn/20201218081104595.jpg#pic_center" alt="logo"></p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>import</tag>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title>下载利器IDM</title>
    <url>/ITech/2020/12/18/%E4%B8%8B%E8%BD%BD%E5%88%A9%E5%99%A8IDM/</url>
    <content><![CDATA[<p>分享一个下载利器 <a href="https://pan.baidu.com/s/1oz2Nqg8LR-NzvA9c8sx7Rw"><strong>IDM</strong></a> 提取码：cl6f。</p>
<p><img src="https://img-blog.csdnimg.cn/20201218081104595.jpg#pic_center" alt="logo"></p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>软件分享</category>
      </categories>
      <tags>
        <tag>IDM</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Win10+Node.js+Git+Hexo在GitHub快速部署博客（恢复）</title>
    <url>/ITech/2018/12/01/%E5%88%A9%E7%94%A8Win10-Node-js-Git-Hexo%E5%9C%A8GitHub%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2-2018-12-01/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客，仅音译，英文名为Blogger,为Web Log的混成词。它的正式名称为网络日记；又音译为部落格或部落阁等。博客是继MSN.BBS.ICQ之后出现的第4种网络交流方式，现已受到大家的欢迎，是网络时代的个人“读者文摘”，是以超级链接为武器的网络日记，它代表着新的生活、工作和学习方式。许多博客专注在特定的课题上提供评论或新闻，其他则被作为比较个人的日记。一个典型的博客结合了文字、图像、其他博客或网站的链接及其它与主题相关的媒体，能够让读者以互动的方式留下意见，是许多博客的重要要素。大部分的博客内容以文字为主，仍有一些博客专注在IT、艺术、摄影、视频、音乐、播客等各种主题。博客是社会媒体网络的一部分。比较著名的有Facebook、新浪、网易等。当下网络如此发达，你不想用有一个自己的博客吗？如果你想要具有一个自己的博客，并且自行定制自己的博客，需要怎么做呢？今天我就以他人受之渔受有缘人。</p>
<span id="more"></span>

<h2 id="Windows10下环境搭建"><a href="#Windows10下环境搭建" class="headerlink" title="Windows10下环境搭建"></a>Windows10下环境搭建</h2><p>以下利用之软件大多皆是开源软件，在Windows下有些软件难免要有版权，如果介意请尽快切换到Linux系统。不过用习惯Windows了要想转Linux还需要一个过渡的过程，加油吧。下面将从以下几方面着重叙述构建博客需要的几个过程，软件的下载尽可能去官网。</p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>可以点击<a href="https://nodejs.org/en/download/">Nodejs官网</a>进行下载，不多赘述，下载64位的（.msi）。</p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>需要点击<a href="https://visualstudio.microsoft.com/zh-hans/downloads/?rr=https://social.msdn.microsoft.com/Forums/vstudio/en-US/e653a57a-bc32-4134-87bf-df33058f0531/download-microsoft-visual-c-2017-redistributable?forum=vssetup">Microsoft Visual C++2017 x64位</a>下载</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装后，win+R启动cmd命令行，输入</p>
<p><code>$ node -v</code><br><code>v10.13.0</code></p>
<p><code>$ npm -v</code><br><code>6.4.1</code></p>
<p>检测是否安装的最新版本。</p>
<h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>安装完node.js后就可以利用<code>npm</code>包管理程序安装 <code>hexo</code>了，利用以下的命令即可：</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p><code>$npm install hexo -save</code></p>
<h3 id="安装hexo命令行组件"><a href="#安装hexo命令行组件" class="headerlink" title="安装hexo命令行组件"></a>安装hexo命令行组件</h3><p><code>$npm install -g hexo-cli</code></p>
<h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><p><code>$hexo init [文件夹名]</code></p>
<h3 id="hexo项目内node-js安装"><a href="#hexo项目内node-js安装" class="headerlink" title="hexo项目内node.js安装"></a>hexo项目内node.js安装</h3><p><code>$npm install</code></p>
<h3 id="添加Git支持"><a href="#添加Git支持" class="headerlink" title="添加Git支持"></a>添加Git支持</h3><p><code>$npm install hexo-deployer-git --save</code></p>
<h3 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a>设置RSS</h3><p><code>$npm install hexo-generator-feed --save</code></p>
<h3 id="查找功能"><a href="#查找功能" class="headerlink" title="查找功能"></a>查找功能</h3><p><code>$npm install hexo-generator-searchdb --save</code></p>
<h3 id="启动项目服务器，在本地测试"><a href="#启动项目服务器，在本地测试" class="headerlink" title="启动项目服务器，在本地测试"></a>启动项目服务器，在本地测试</h3><p><code>$hexo s</code></p>
<p><code>$hexo -v</code></p>
<p><code>hexo: 3.8.0</code><br><code>hexo-cli: 1.1.0</code><br><code>os: Windows_NT 10.0.17134 win32 x64</code><br><code>http_parser: 2.8.0</code><br><code>node: 10.13.0</code><br><code>v8: 6.8.275.32-node.36</code><br><code>uv: 1.23.2</code><br><code>zlib: 1.2.11</code><br><code>ares: 1.14.0</code><br><code>modules: 64</code><br><code>nghttp2: 1.34.0</code><br><code>napi: 3</code><br><code>openssl: 1.1.0i</code><br><code>icu: 62.1</code><br><code>unicode: 11.0</code><br><code>cldr: 33.1</code><br><code>tz: 2018e</code></p>
<h3 id="Git安装及GitHub配置"><a href="#Git安装及GitHub配置" class="headerlink" title="Git安装及GitHub配置"></a>Git安装及GitHub配置</h3><ol>
<li><a href="https://git-scm.com/download/win">下载地址</a> 选择Windows版本下载，安装按照默认点击“下一步”即可。</li>
<li>配置GitHub<br>注册GitHub账号，<a href="https://github.com/">注册网址：</a>。</li>
</ol>
<p>打开<em>git-bash</em>，配置Git全局变量</p>
<p><code>$ git config --global user.name &quot;username&quot;</code></p>
<p><code>$ git config --global user.email &quot;email-for-git&quot;</code></p>
<p>打开 <em>git-bash</em> 在本地生成SSH key <code>$ ssh-keygen -t rsa -C &quot;email-for-Github&quot;</code>；打开 <em>ssh-agent</em> ， <code>$ eval (ssh-agent -s)</code>；生成私钥 <code>$ ssh-add ~/.ssh/id_rsa</code>；在 <em>.ssh</em> 目录中创建配置文件 <em>config</em>，编辑如下：</p>
<p><code>Host one.github.com</code></p>
<p><code>HostName github.com</code></p>
<p><code>PreferredAuthentications publickey</code></p>
<p><code>IdentityFile ~/.ssh/id_rsa_one</code></p>
<p><code>User one</code></p>
<p>进入账号设置（Settings），配置 SSH keys,将生成的<em>id_rsa.pub</em>中的公钥填入其中；<br>新建一个repository，并命名；进入此repository，选择“Settings”，在GitHub Pages 选项中启用发布网站。</p>
<h3 id="Markdownpad2安装"><a href="#Markdownpad2安装" class="headerlink" title="Markdownpad2安装"></a>Markdownpad2安装</h3><p>所需依赖 <a href="https://pan.baidu.com/s/1ivWd6bc2IBJ0j_qBeD74sg">** Awesomium SDK **下载地址</a>提取码：g656<br><a href="http://markdownpad.com/">Markdownpad2下载地址</a><br>安装略。此软件为编辑hexo生成的 <em>.md</em> 网站文件,也可以用VSCode哦。</p>
<h2 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h2><p>hexo主配置文件，主目录下 <em>_config.yml</em></p>
<p>theme配置文件，theme目录下 <em>_config.yml</em></p>
<p>请自行查找配置方法，参看<a href="https://hexo.io/zh-cn/docs/">hexo官网文档</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>千里之行始于足下</p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
        <tag>MarkdownPro2</tag>
        <tag>Node.js</tag>
        <tag>GitHub</tag>
        <tag>npm</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用sudo命令在Linux中部署超级用户权限（恢复）</title>
    <url>/ITech/2018/12/02/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-sudo-%E5%91%BD%E4%BB%A4%E5%9C%A8-Linux-%E4%B8%AD%E9%83%A8%E7%BD%B2%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90-2018-12-02/</url>
    <content><![CDATA[<p><strong>sudo</strong> 命令在你想要使用超级权限运行一条临时的命令时非常方便，但是当它不能做到你期望的所有事的时候，你也会遇到一些麻烦。比如说你想在某些日志文件结尾添加一些重要的信息，你可能会尝试这样做：  </p>
<span id="more"></span>

<pre><code>$ echo &quot;Important note&quot; &gt;&gt; /var/log/somelog
-bash: /var/log/somelog: Permission denied</code></pre>
<p>好吧，看起来你似乎需要一些额外的特权。一般来说，你不能使用你的用户账号向系统日志中写入东西。我们使用 <strong>sudo</strong> 再尝试一次吧。  </p>
<pre><code>$ sudo !!
sudo echo &quot;Important note&quot; &gt;&gt; /var/log/somelog
-bash: /var/log/somelog: Permission denied</code></pre>
<p>emmm，它还是没有啥反应。我们来试点不同的吧。  </p>
<pre><code>$ sudo &#39;echo &quot;Important note&quot; &gt;&gt; /var/log/somelog&#39;
sudo: echo &quot;Important note&quot; &gt;&gt; /var/log/somelog: command not found</code></pre>
<p><strong>也可以查看：</strong><a href="https://www.networkworld.com/article/3242170/linux/invaluable-tips-and-tricks-for-troubleshooting-linux.html">在 Linux 下排查故障的宝贵提示和技巧</a></p>
<h3 id="接下来该干什么？"><a href="#接下来该干什么？" class="headerlink" title="接下来该干什么？"></a>接下来该干什么？</h3><p>上面在执行完第一条命令后的回应显示，我们缺少向日志文件写入时必须的特权。第二次，我们使用 root 权限运行了第一次的命令，但是返回了一个 <strong>没有权限</strong> 的错误。第三次，我们把整个命令放在一个引号里面再运行了一遍，返回了一个 <strong>没有发现命令</strong> 的错误。所以，到底错在哪里了呢？</p>
<ul>
<li><p>第一条命令：没有 root 特权，你无法向这个日志中写入东西。</p>
</li>
<li><p>第二条命令：你的超级权限没有被正确重定位。</p>
</li>
<li><p>第三条命令：Sudo 不理解你用引号括起来的整个 “命令”。</p>
</li>
</ul>
<p>在你的用户还未添加到 sudo 用户组的时候，如果尝试使用 sudo，你可能已经看到过像下面的这么一条命令了：  </p>
<pre><code>nemo is not in the sudoers file. This incident will be reported.</code></pre>
<h3 id="你可以做什么？"><a href="#你可以做什么？" class="headerlink" title="你可以做什么？"></a>你可以做什么？</h3><p>一个相当简单的选择就是使用 sudo 命令成为 root。鉴于你已经有了 sudo 特权，你可以使用下面的命令执行此操作：  </p>
<pre><code>$ sudo su
[sudo] password for nemo:</code></pre>
<p>注意这个改变的符号表明了你的新身份。然后你就可以以 root 运行之前的命令了：  </p>
<pre><code>echo &quot;Important note&quot; &gt;&gt; /var/log/somelog</code></pre>
<p>接着你可以输入 <strong>^d</strong> 返回你之前的身份。当然了，一些 sudo 的配置可能会阻止你使用 sudo 命令成为 root。</p>
<p>用 <strong>su</strong> 命令是另一个切换用户为 root 的选择，但是这需要你知道 root 密码许多人被赋予了访问 sudo 的权限，而且无需提供 root 密码，所以这并不是总有用。  </p>
<p>切换到 root 之后，你就可以以 root 的身份运行任何你想执行的命令了。要想通过这种途径有三个问题 1) 每个想要使用 root 特权的人都需要事先知道 root 的密码（这样很不安全） 2) 如果在运行需要 root 权限的特定命令后未能退出特权状态，你的系统可能会受到一些重大错误的波及。最好 <em>只有</em> 当你真的需要 root 特权，以及能控制好每个 sudo 用户可以拥有多少 root 权限的时候再去使用它。在使用完 root 特权之后，最好及时恢复到普通用户的状态。  </p>
<p>另外请注意，整个讨论的前提是你可以正常地访问 sudo，并且你的访问权限没有受限。详细的内容后面会介绍到。  </p>
<p>还有一个选择就是使用一个不同的命令。如果通过编辑文件从而在其后添加内容是一种选择的话，你也许可以使用 “sudo vi /var/log/somelog”，通过编辑一个活跃的日志文件通常不是一个好办法，因为系统可能会频繁的向这个文件中进行写入操作。  </p>
<p>最后一个但是有点复杂的选择是，使用下列可以解决我们之前看到的问题的命令之一，但是它们涉及到了很多复杂的语法。第一个命令允许你在得到 “没有权限” 的拒绝之后可以使用 !! 重复你的命令：  </p>
<pre><code>$ sudo echo &quot;Important note&quot; &gt;&gt; /var/log/somelog
-bash: /var/log/somelog: Permission denied
$ !!:gs/&gt;/|sudo tee -a / &lt;=====
$ tail -1 /var/log/somelog
Important note</code></pre>
<p>第二种是通过 sudo 命令，把你想要添加的信息传递给 <strong>tee</strong>。注意，**-a** 指定了你要添加文本的目标文件：  </p>
<pre><code>$ echo &quot;Important note&quot; | sudo tee -a /var/log/somelog
$ tail -1 /var/log/somelog
Important note</code></pre>
<h3 id="sudo-有多可控？"><a href="#sudo-有多可控？" class="headerlink" title="sudo 有多可控？"></a>sudo 有多可控？</h3><p>回答这个问题最快速的回答就是，它取决于管理它的人。大多数 Linux 的默认设置都非常简单。如果一个用户被安排到了一个特别的组中，例如 <strong>wheel</strong> 或者 <strong>admin</strong> 组，那这个用户无需知道 root 的密码就可以拥有运行任何命令的能力。这就是大多数 Linux 系统中的默认设置。一旦在 <strong>/etc/group</strong> 中添加了一个用户到了特权组中，这个用户就可以以 root 的权力运行任何命令。另一方面，可以配置 sudo，以便一些用户只能够以 root 身份运行单一指令或者一组命令中的任何一个。  </p>
<p>如果把像下面展示的这些行添加到了 <strong>/etc/sudoers</strong> 文件中，例如 “nemo” 这个用户可以以 root 身份运行 <strong>whoami</strong> 命令。在现实中，这可能不会造成任何影响，作为一个例子，它做的非常好。  </p>
<pre><code># User alias specification
nemo ALL=(root) NOPASSWD: WHOAMI

# Cmnd alias specification
Cmnd_Alias WHOAMI = /usr/bin/whoami</code></pre>
<p>注意，我们添加了一个命令别名（Cmnd_Alias），它指定了一个可以运行的命令的全路径，以及一个用户别名，允许这个用户无需密码就可以使用 sudo 执行的单个命令。  </p>
<p>当 nemo 运行 <strong>sudo whoami</strong> 命令的时候，他将会看到这个：  </p>
<pre><code>$ sudo whoami
root</code></pre>
<p>注意这个，一旦 nemo 使用 sudo 执行了这条命令，<strong>whoami</strong> 会显示此时的用户是 <strong>root</strong>。  </p>
<p>至于其他的命令，nemo 将会看到像这样的一些内容：  </p>
<pre><code>$ sudo date
[sudo] password for nemo:
Sorry, user nemo is not allowed to execute &#39;/bin/date&#39; as root on butterfly.</code></pre>
<h3 id="sudo-的默认设置"><a href="#sudo-的默认设置" class="headerlink" title="sudo 的默认设置"></a>sudo 的默认设置</h3><p>在默认路径中，我们会利用像下面展示的 <strong>/etc/sudoers</strong> 文件中的几行：  </p>
<pre><code>$ sudo egrep &quot;admin|sudo&quot; /etc/sudoers
# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL        &lt;=====
# Allow members of group sudo to execute any command
%sudo ALL=(ALL:ALL) ALL &lt;=====</code></pre>
<p>在这几行中，**%admin** 和 <strong>%sudo</strong> 都说明了任何添加到这些组中的人都可以使用 sudo 命令 以 root 的身份运行任何命令。  </p>
<p>下面列出的是 /etc/group 中的一行，它意味着每一个在该组中列出的成员，都拥有了 sudo 特权，而无需在 /etc/sudoers 中进行任何修改。  </p>
<pre><code>sudo:x:27:shs,nemo</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>sudo 命令意味着你可以根据需要轻松地部署超级用户的访问权限，而且只有在需要的时候才能赋予用户非常有限的特权访问权限。你可能会遇到一些与简单的 “sudo command” 不同的问题，不过在 <strong>sudo</strong> 的回应中应该会显示你遇到了什么问题。  </p>
<p>欢迎加入 <a href="https://www.facebook.com/NetworkWorld/">Facebook</a> 和 <a href="https://www.linkedin.com/company/network-world">LinkedIn</a> 上的 Network World 社区，并在其中重要的主题下进行留言评论。  </p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>MarkdownPro2</tag>
        <tag>LinuxShell</tag>
      </tags>
  </entry>
  <entry>
    <title>就是一篇随笔随笔</title>
    <url>/ITech/2020/12/22/%E5%B0%B1%E6%98%AF%E4%B8%80%E7%AF%87%E9%9A%8F%E7%AC%94%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>兴许若干年后，Linux和Windows一样不可替代吧。:)</p>
<p>2020注定是一个不平凡而又平凡的甲子年，Hang In There！！</p>
<p><img src="https://img-blog.csdnimg.cn/20201218081104595.jpg#pic_center" alt="logo"></p>
<link rel="stylesheet" href="/ITech/css/spoiler.css" type="text/css"><script src="/ITech/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
